-- ===================
-- === SCRAPE JOBS ===
-- ===================
CREATE SCHEMA IF NOT EXISTS scrape;

CREATE TABLE IF NOT EXISTS scrape.job (
    id                 INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    name               TEXT NOT NULL,
    description        TEXT,
    platforms          TEXT[] NOT NULL DEFAULT '{}',
    time_range         tstzrange,
    term_set_snapshot  JSONB,
    config_snapshot    JSONB,
    status             TEXT NOT NULL DEFAULT 'completed',
    notes              TEXT
);

-- ================
-- === TAXONOMY ===
-- ================
CREATE SCHEMA IF NOT EXISTS taxonomy;

CREATE TABLE IF NOT EXISTS taxonomy.vaccine_term (
    id            INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    date_entered  TIMESTAMPTZ NOT NULL DEFAULT now(),
    name          TEXT NOT NULL UNIQUE,
    type          TEXT NOT NULL  -- e.g., 'vaccine' | 'disease' | 'person' | 'organization'
);

-- ====================
-- === SOCIAL MEDIA ===
-- ====================
-- Common conventions:
--  - filtered_text: sanitized version of primary text
--  - tsv_en: stored tsvector on filtered_text
--  - created_at_ts: normalized timestamp
CREATE SCHEMA IF NOT EXISTS sm;

CREATE TABLE IF NOT EXISTS sm.tweet (
    id               BIGINT PRIMARY KEY,
    date_entered     TIMESTAMPTZ NOT NULL DEFAULT now(),
    source           TEXT NOT NULL,
    conversation_id  BIGINT NOT NULL,
    created_at_ts    TIMESTAMPTZ NOT NULL,
    tweet_text       TEXT NOT NULL,
    filtered_text    TEXT NOT NULL,
    tsv_en           tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    retweet_count    INTEGER,
    like_count       INTEGER,
    reply_count      INTEGER,
    quote_count      INTEGER,
    is_en            BOOLEAN
);

CREATE TABLE IF NOT EXISTS sm.reddit_submission (
    id                        TEXT PRIMARY KEY,
    date_entered              TIMESTAMPTZ NOT NULL DEFAULT now(),
    url                       TEXT NOT NULL,
    url_hash                  VARCHAR(32) GENERATED ALWAYS AS (MD5(url)) STORED,
    domain                    TEXT NOT NULL,
    title                     TEXT NOT NULL,
    filtered_text             TEXT NOT NULL,
    tsv_en                    tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    permalink                 TEXT,
    created_at_ts             TIMESTAMPTZ NOT NULL,
    url_overridden_by_dest    TEXT,
    subreddit_id              TEXT NOT NULL,
    subreddit                 TEXT NOT NULL,
    upvote_ratio              NUMERIC NOT NULL,
    score                     INTEGER NOT NULL,
    gilded                    INTEGER NOT NULL,
    num_comments              INTEGER NOT NULL,
    num_crossposts            INTEGER NOT NULL,
    pinned                    BOOLEAN NOT NULL DEFAULT FALSE,
    stickied                  BOOLEAN NOT NULL DEFAULT FALSE,
    over_18                   BOOLEAN NOT NULL DEFAULT FALSE,
    is_created_from_ads_ui    BOOLEAN NOT NULL DEFAULT FALSE,
    is_self                   BOOLEAN NOT NULL DEFAULT FALSE,
    is_video                  BOOLEAN NOT NULL DEFAULT FALSE,
    media                     JSONB,
    gildings                  JSONB,
    all_awardings             JSONB,
    is_en                     BOOLEAN
);

-- reddit comments can only be entered if their parent submission ("link_id") has been entered
CREATE TABLE IF NOT EXISTS sm.reddit_comment (
    id                      TEXT PRIMARY KEY,
    date_entered            TIMESTAMPTZ NOT NULL DEFAULT now(),
    link_id                 TEXT NOT NULL,
    parent_comment_id       TEXT NULL REFERENCES sm.reddit_comment(id) ON DELETE CASCADE,
    body                    TEXT NOT NULL,
    filtered_text           TEXT NOT NULL,
    tsv_en                  tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    permalink               TEXT NOT NULL,
    created_at_ts           TIMESTAMPTZ NOT NULL,
    subreddit_id            TEXT NOT NULL,
    subreddit_type          TEXT,
    total_awards_received   INTEGER NOT NULL,
    subreddit               TEXT NOT NULL,
    score                   INTEGER NOT NULL,
    gilded                  INTEGER NOT NULL,
    stickied                BOOLEAN NOT NULL DEFAULT FALSE,
    is_submitter            BOOLEAN NOT NULL DEFAULT FALSE,
    gildings                JSONB,
    all_awardings           JSONB,
    is_en                   BOOLEAN,
    CONSTRAINT reddit_comment_submission_fk
        FOREIGN KEY (link_id) REFERENCES sm.reddit_submission(id) ON DELETE CASCADE
);

-- I don't remember if it was necesasry to use the dual key (channel_id, message_id), 
-- but it doesn't hurt i guess
CREATE TABLE IF NOT EXISTS sm.telegram_post (
    channel_id      BIGINT NOT NULL,
    message_id      BIGINT NOT NULL,
    PRIMARY KEY (channel_id, message_id),
    date_entered    TIMESTAMPTZ NOT NULL DEFAULT now(),
    link            TEXT NOT NULL,
    link_hash       VARCHAR(32) GENERATED ALWAYS AS (MD5(link)) STORED,
    created_at_ts   TIMESTAMPTZ NOT NULL,
    text            TEXT NOT NULL,
    filtered_text   TEXT NOT NULL,
    tsv_en          tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    views           INTEGER,
    forwards        INTEGER,
    replies         INTEGER,
    reactions_total INTEGER,
    is_pinned       BOOLEAN NOT NULL DEFAULT FALSE,
    has_media       BOOLEAN NOT NULL DEFAULT FALSE,
    raw_type        TEXT,
    is_en           BOOLEAN
);

CREATE TABLE IF NOT EXISTS sm.youtube_video (
    video_id        TEXT PRIMARY KEY,
    date_entered    TIMESTAMPTZ NOT NULL DEFAULT now(),
    url             TEXT NOT NULL,
    url_hash        VARCHAR(32) GENERATED ALWAYS AS (MD5(url)) STORED,
    title           TEXT NOT NULL,
    filtered_text   TEXT NOT NULL,  -- derived from title
    tsv_en          tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    description     TEXT,
    created_at_ts   TIMESTAMPTZ NOT NULL,
    channel_id      TEXT NOT NULL,
    channel_title   TEXT,
    duration_iso    TEXT,
    view_count      BIGINT,
    like_count      BIGINT,
    comment_count   BIGINT,
    is_en           BOOLEAN
);

-- youtube comments can only be entered if their parent video ("video_id") has been entered
CREATE TABLE IF NOT EXISTS sm.youtube_comment (
    video_id        TEXT NOT NULL,
    comment_id      TEXT NOT NULL,
    PRIMARY KEY (video_id, comment_id),
    date_entered    TIMESTAMPTZ NOT NULL DEFAULT now(),
    comment_url     TEXT NOT NULL,
    comment_url_hash VARCHAR(32) GENERATED ALWAYS AS (MD5(comment_url)) STORED,
    text            TEXT NOT NULL,
    filtered_text   TEXT NOT NULL,
    tsv_en          tsvector GENERATED ALWAYS AS (to_tsvector('english', filtered_text)) STORED,
    created_at_ts   TIMESTAMPTZ NOT NULL,
    like_count      BIGINT,
    raw             JSONB,
    is_en           BOOLEAN,
    CONSTRAINT youtube_comment_video_fk
        FOREIGN KEY (video_id) REFERENCES sm.youtube_video(video_id) ON DELETE CASCADE
);

-- ===========================
-- === Post Registry (sm)  ===
-- ===========================
CREATE TABLE IF NOT EXISTS sm.post_registry (
    id        BIGSERIAL PRIMARY KEY,
    platform  TEXT NOT NULL,  -- 'tweet'|'reddit_submission'|'reddit_comment'|'telegram_post'|'youtube_video'|'youtube_comment'
    key1      TEXT NOT NULL,  -- native id or first of composite key
    key2      TEXT,           -- second of composite key (NULL for single-key sources)
    post_key  TEXT GENERATED ALWAYS AS (
                 CASE platform
                   WHEN 'tweet'             THEN platform || ':' || key1
                   WHEN 'reddit_submission' THEN platform || ':' || key1
                   WHEN 'reddit_comment'    THEN platform || ':' || key1
                   WHEN 'youtube_video'     THEN platform || ':' || key1
                   WHEN 'youtube_comment'   THEN platform || ':' || key1 || ':' || COALESCE(key2,'')
                   WHEN 'telegram_post'     THEN platform || ':' || key1 || ':' || COALESCE(key2,'')
                   ELSE platform || ':' || key1 || COALESCE(':'||key2,'')
                 END
               ) STORED,
    CONSTRAINT post_registry_uniq UNIQUE (platform, key1, key2)
);

CREATE INDEX IF NOT EXISTS post_registry_platform_idx ON sm.post_registry(platform);

-- =================================
-- Registry triggers (INSERT/DELETE)
-- =================================
-- triggers to auto-enter data into registry for each platform

-- TWEET ----------------------------------------------------------
CREATE OR REPLACE FUNCTION sm.trg_tweet_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('tweet', NEW.id::text, NULL)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_tweet_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='tweet' AND key1=OLD.id::text AND key2 IS NULL;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS tweet_reg_ins ON sm.tweet;
CREATE TRIGGER tweet_reg_ins
AFTER INSERT ON sm.tweet
FOR EACH ROW EXECUTE FUNCTION sm.trg_tweet_reg_ins();

DROP TRIGGER IF EXISTS tweet_reg_del ON sm.tweet;
CREATE TRIGGER tweet_reg_del
AFTER DELETE ON sm.tweet
FOR EACH ROW EXECUTE FUNCTION sm.trg_tweet_reg_del();


-- REDDIT SUBMISSION ----------------------------------------------
CREATE OR REPLACE FUNCTION sm.trg_rs_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('reddit_submission', NEW.id, NULL)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_rs_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='reddit_submission' AND key1=OLD.id AND key2 IS NULL;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS rs_reg_ins ON sm.reddit_submission;
CREATE TRIGGER rs_reg_ins
AFTER INSERT ON sm.reddit_submission
FOR EACH ROW EXECUTE FUNCTION sm.trg_rs_reg_ins();

DROP TRIGGER IF EXISTS rs_reg_del ON sm.reddit_submission;
CREATE TRIGGER rs_reg_del
AFTER DELETE ON sm.reddit_submission
FOR EACH ROW EXECUTE FUNCTION sm.trg_rs_reg_del();


-- REDDIT COMMENT -------------------------------------------------
CREATE OR REPLACE FUNCTION sm.trg_rc_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('reddit_comment', NEW.id, NULL)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_rc_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='reddit_comment' AND key1=OLD.id AND key2 IS NULL;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS rc_reg_ins ON sm.reddit_comment;
CREATE TRIGGER rc_reg_ins
AFTER INSERT ON sm.reddit_comment
FOR EACH ROW EXECUTE FUNCTION sm.trg_rc_reg_ins();

DROP TRIGGER IF EXISTS rc_reg_del ON sm.reddit_comment;
CREATE TRIGGER rc_reg_del
AFTER DELETE ON sm.reddit_comment
FOR EACH ROW EXECUTE FUNCTION sm.trg_rc_reg_del();


-- TELEGRAM POST (composite key) ---------------------------------
CREATE OR REPLACE FUNCTION sm.trg_tg_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('telegram_post', NEW.channel_id::text, NEW.message_id::text)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_tg_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='telegram_post'
     AND key1=OLD.channel_id::text
     AND key2=OLD.message_id::text;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS tg_reg_ins ON sm.telegram_post;
CREATE TRIGGER tg_reg_ins
AFTER INSERT ON sm.telegram_post
FOR EACH ROW EXECUTE FUNCTION sm.trg_tg_reg_ins();

DROP TRIGGER IF EXISTS tg_reg_del ON sm.telegram_post;
CREATE TRIGGER tg_reg_del
AFTER DELETE ON sm.telegram_post
FOR EACH ROW EXECUTE FUNCTION sm.trg_tg_reg_del();


-- YOUTUBE VIDEO --------------------------------------------------
CREATE OR REPLACE FUNCTION sm.trg_yv_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('youtube_video', NEW.video_id, NULL)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_yv_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='youtube_video' AND key1=OLD.video_id AND key2 IS NULL;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS yv_reg_ins ON sm.youtube_video;
CREATE TRIGGER yv_reg_ins
AFTER INSERT ON sm.youtube_video
FOR EACH ROW EXECUTE FUNCTION sm.trg_yv_reg_ins();

DROP TRIGGER IF EXISTS yv_reg_del ON sm.youtube_video;
CREATE TRIGGER yv_reg_del
AFTER DELETE ON sm.youtube_video
FOR EACH ROW EXECUTE FUNCTION sm.trg_yv_reg_del();


-- YOUTUBE COMMENT (composite key) --------------------------------
CREATE OR REPLACE FUNCTION sm.trg_yc_reg_ins() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO sm.post_registry(platform, key1, key2)
  VALUES ('youtube_comment', NEW.video_id, NEW.comment_id)
  ON CONFLICT (platform, key1, key2) DO NOTHING;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION sm.trg_yc_reg_del() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  DELETE FROM sm.post_registry
   WHERE platform='youtube_comment'
     AND key1=OLD.video_id AND key2=OLD.comment_id;
  RETURN OLD;
END $$;

DROP TRIGGER IF EXISTS yc_reg_ins ON sm.youtube_comment;
CREATE TRIGGER yc_reg_ins
AFTER INSERT ON sm.youtube_comment
FOR EACH ROW EXECUTE FUNCTION sm.trg_yc_reg_ins();

DROP TRIGGER IF EXISTS yc_reg_del ON sm.youtube_comment;
CREATE TRIGGER yc_reg_del
AFTER DELETE ON sm.youtube_comment
FOR EACH ROW EXECUTE FUNCTION sm.trg_yc_reg_del();


-- ==================================
-- === Unified, read-only post view ==
-- ==================================
CREATE OR REPLACE VIEW sm.posts_unified AS
    -- Tweets
    SELECT
        pr.id AS post_id,
        'tweet'::text AS platform,
        t.id::text AS native_id,
        t.created_at_ts AS created_at_ts,
        t.tweet_text AS text,
        NULL::text AS url
    FROM sm.post_registry pr
    JOIN sm.tweet t
      ON pr.platform = 'tweet'
     AND pr.key1 = t.id::text

    UNION ALL
    -- Reddit submissions
    SELECT
        pr.id,
        'reddit_submission',
        rs.id,
        rs.created_at_ts,
        rs.title,
        rs.permalink
    FROM sm.post_registry pr
    JOIN sm.reddit_submission rs
      ON pr.platform = 'reddit_submission'
     AND pr.key1 = rs.id

    UNION ALL
    -- Reddit comments
    SELECT
        pr.id,
        'reddit_comment',
        rc.id,
        rc.created_at_ts,
        rc.body,
        rc.permalink
    FROM sm.post_registry pr
    JOIN sm.reddit_comment rc
      ON pr.platform = 'reddit_comment'
     AND pr.key1 = rc.id

    UNION ALL
    -- YouTube videos
    SELECT
        pr.id,
        'youtube_video',
        yv.video_id,
        yv.created_at_ts,
        yv.title,
        yv.url
    FROM sm.post_registry pr
    JOIN sm.youtube_video yv
      ON pr.platform = 'youtube_video'
     AND pr.key1 = yv.video_id

    UNION ALL
    -- YouTube comments
    SELECT
        pr.id,
        'youtube_comment',
        (yc.video_id || ':' || yc.comment_id),
        yc.created_at_ts,
        yc.text,
        yc.comment_url
    FROM sm.post_registry pr
    JOIN sm.youtube_comment yc
      ON pr.platform = 'youtube_comment'
     AND pr.key1 = yc.video_id
     AND pr.key2 = yc.comment_id

    UNION ALL
    -- Telegram posts
    SELECT
        pr.id,
        'telegram_post',
        (tp.channel_id::text || ':' || tp.message_id::text),
        tp.created_at_ts,
        tp.text,
        tp.link
    FROM sm.post_registry pr
    JOIN sm.telegram_post tp
      ON pr.platform = 'telegram_post'
     AND pr.key1 = tp.channel_id::text
     AND pr.key2 = tp.message_id::text
;

-- ===========================================
-- === Link scrape jobs & term matches (via registry)
-- ===========================================
CREATE TABLE IF NOT EXISTS scrape.post_scrape (
    scrape_job_id  INT    NOT NULL REFERENCES scrape.job(id) ON DELETE CASCADE,
    post_id        BIGINT NOT NULL REFERENCES sm.post_registry(id) ON DELETE CASCADE,
    linked_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (scrape_job_id, post_id)
);

CREATE INDEX IF NOT EXISTS post_scrape_post_idx ON scrape.post_scrape (post_id);

CREATE SCHEMA IF NOT EXISTS matches;

CREATE TABLE IF NOT EXISTS matches.post_term_match (
    post_id         BIGINT NOT NULL REFERENCES sm.post_registry(id) ON DELETE CASCADE,
    term_id         INT    NOT NULL REFERENCES taxonomy.vaccine_term(id) ON DELETE CASCADE,
    matched_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    matcher_version TEXT,
    confidence      NUMERIC, -- TODO: don't remember why i included this; consider dropping
    PRIMARY KEY (post_id, term_id)
);

CREATE INDEX IF NOT EXISTS post_term_match_term_idx ON matches.post_term_match (term_id, post_id);

-- ================
-- === PODCASTS ===
-- ================
CREATE SCHEMA IF NOT EXISTS podcasts;

CREATE TABLE IF NOT EXISTS podcasts.shows (
    id            INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    date_entered  TIMESTAMPTZ NOT NULL DEFAULT now(),
    title         TEXT NOT NULL,
    rss_url       TEXT,
    rss_url_hash  VARCHAR(32) GENERATED ALWAYS AS (MD5(rss_url)) STORED,
    CONSTRAINT podcasts_rss_url_uniq UNIQUE (rss_url)
);

CREATE TABLE IF NOT EXISTS podcasts.episodes (
    id            TEXT PRIMARY KEY,
    date_entered  TIMESTAMPTZ NOT NULL DEFAULT now(),
    audio_path    TEXT NOT NULL,
    guid          TEXT NOT NULL,
    title         TEXT,
    description   TEXT,
    created_at_ts TIMESTAMPTZ,
    download_url  TEXT,
    podcast_id    INT NOT NULL REFERENCES podcasts.shows(id) ON DELETE CASCADE,
    CONSTRAINT episodes_podcast_guid_uniq UNIQUE (podcast_id, guid)
);

CREATE TABLE IF NOT EXISTS podcasts.transcript_segments (
    id            BIGSERIAL PRIMARY KEY,
    episode_id    TEXT NOT NULL REFERENCES podcasts.episodes(id) ON DELETE CASCADE,
    seg_idx       INT  NOT NULL,
    start_s       NUMERIC NOT NULL,
    end_s         NUMERIC NOT NULL,
    text          TEXT,
    filtered_text TEXT,
    tsv_en        tsvector GENERATED ALWAYS AS (
                      to_tsvector('english', COALESCE(filtered_text, text))
                  ) STORED,
    CONSTRAINT transcript_segments_ep_seg_uniq UNIQUE (episode_id, seg_idx),
    CONSTRAINT transcript_segments_time_chk CHECK (end_s >= start_s)
);


-- ===================
-- === INDICES ETC ===
-- ===================
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- Azure Portal → your Postgres Flexible Server → Server parameters → set azure.extensions to include pg_trgm

-- Full-text
CREATE INDEX IF NOT EXISTS tweet_tsv_en_gin    ON sm.tweet              USING GIN (tsv_en);
CREATE INDEX IF NOT EXISTS rs_tsv_en_gin       ON sm.reddit_submission  USING GIN (tsv_en);
CREATE INDEX IF NOT EXISTS rc_tsv_en_gin       ON sm.reddit_comment     USING GIN (tsv_en);
CREATE INDEX IF NOT EXISTS yv_tsv_en_gin       ON sm.youtube_video      USING GIN (tsv_en);
CREATE INDEX IF NOT EXISTS yc_tsv_en_gin       ON sm.youtube_comment    USING GIN (tsv_en);
CREATE INDEX IF NOT EXISTS seg_text_tsv_en_gin ON podcasts.transcript_segments USING GIN (tsv_en);

-- Episodes (expression GINs)
CREATE INDEX IF NOT EXISTS ep_title_tsv_gin ON podcasts.episodes USING GIN (to_tsvector('english', COALESCE(title, '')));
CREATE INDEX IF NOT EXISTS ep_desc_tsv_gin  ON podcasts.episodes USING GIN (to_tsvector('english', COALESCE(description, '')));

-- Trigram
CREATE INDEX IF NOT EXISTS tweet_text_trgm  ON sm.tweet             USING GIN (tweet_text gin_trgm_ops);
CREATE INDEX IF NOT EXISTS rs_title_trgm    ON sm.reddit_submission USING GIN (title gin_trgm_ops);
CREATE INDEX IF NOT EXISTS rc_body_trgm     ON sm.reddit_comment    USING GIN (body gin_trgm_ops);
CREATE INDEX IF NOT EXISTS yv_title_trgm    ON sm.youtube_video     USING GIN (title gin_trgm_ops);
CREATE INDEX IF NOT EXISTS yv_desc_trgm     ON sm.youtube_video     USING GIN (description gin_trgm_ops);
CREATE INDEX IF NOT EXISTS yc_text_trgm     ON sm.youtube_comment   USING GIN (text gin_trgm_ops);

-- Time (BRIN)
CREATE INDEX IF NOT EXISTS tweet_created_at_brin ON sm.tweet             USING BRIN (created_at_ts);
CREATE INDEX IF NOT EXISTS rs_created_at_brin    ON sm.reddit_submission USING BRIN (created_at_ts);
CREATE INDEX IF NOT EXISTS rc_created_at_brin    ON sm.reddit_comment    USING BRIN (created_at_ts);
CREATE INDEX IF NOT EXISTS yv_created_at_brin    ON sm.youtube_video     USING BRIN (created_at_ts);
CREATE INDEX IF NOT EXISTS yc_created_at_brin    ON sm.youtube_comment   USING BRIN (created_at_ts);
CREATE INDEX IF NOT EXISTS tg_created_at_brin    ON sm.telegram_post     USING BRIN (created_at_ts);

-- Optional English-only partials
CREATE INDEX IF NOT EXISTS tweet_en_time_idx ON sm.tweet(created_at_ts, id)            WHERE is_en IS TRUE;
CREATE INDEX IF NOT EXISTS rs_en_time_idx    ON sm.reddit_submission(created_at_ts, id) WHERE is_en IS TRUE;
CREATE INDEX IF NOT EXISTS rc_en_time_idx    ON sm.reddit_comment(created_at_ts, id)    WHERE is_en IS TRUE;

-- Common joins / filters
CREATE INDEX IF NOT EXISTS tweet_conversation_idx ON sm.tweet(conversation_id);
CREATE INDEX IF NOT EXISTS rc_link_idx            ON sm.reddit_comment(link_id);
CREATE INDEX IF NOT EXISTS rc_parent_comment_idx  ON sm.reddit_comment(parent_comment_id);
CREATE INDEX IF NOT EXISTS rs_subreddit_idx       ON sm.reddit_submission(subreddit);
CREATE INDEX IF NOT EXISTS rc_subreddit_idx       ON sm.reddit_comment(subreddit);

-- Popularity
CREATE INDEX IF NOT EXISTS rs_score_idx   ON sm.reddit_submission(score);
CREATE INDEX IF NOT EXISTS rc_score_idx   ON sm.reddit_comment(score);
CREATE INDEX IF NOT EXISTS tweet_like_idx ON sm.tweet(like_count);